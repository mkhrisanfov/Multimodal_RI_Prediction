"""CNN2D neural network block and DataLoader"""
import numpy as np
import pandas as pd
import torch
from torch import nn
from torch.utils.data import DataLoader, Dataset
from sklearn.model_selection  import train_test_split

class CNN2D(nn.Module):
    """CNN2D class from the original paper implemented in Python with PyTorch"""
    def __init__(self):
        super(CNN2D, self).__init__()
        self.conv_0=nn.Sequential(
            nn.Conv2d(15,50,4,1),
            nn.ReLU(),
            nn.MaxPool2d(2,2),
            nn.Conv2d(50,300,4,1),
            nn.ReLU(),
            nn.MaxPool2d(2,2),
            nn.Conv2d(300,300,4,1),
            nn.ReLU(),
        )
        self.fc_0=nn.Sequential(
            nn.Linear(337,600),
            nn.ReLU(),
            nn.Linear(600,1),
            nn.Identity()
        )
    def forward(self,x,col):
        x=self.conv_0(x)
        # dimensions of all training tensors are 15*64*64 or 15*65*65
        # so using sum instead of average pooling for each leayer makes
        # much more sense from performance standpoint without any 
        # meaningful sacrifices in overall architecture
        x=x.sum(dim=[2,3],keepdim=True).squeeze()
        x=torch.cat([x,col],dim=1)
        return self.fc_0(x)

class CNN2D_Dataset(Dataset):
    """Dataset class for CNN2D neural network.
    It uses pre-generated by RdKit 2D images stored as numpy arrays
    and distributes them along with encoding types of columns."""
    def __init__(self, dataframe,en_2d,unique_formulas,mask=None): 
        def _make_index(formulas,unique_formulas):
            d0=dict(zip(unique_formulas,range(len(unique_formulas))))
            d={}
            for i,val in enumerate(formulas):
                idx=d0.get(val,None)
                if idx is None:
                    print(f"Formula error: {val}")
                d[i]=idx
            return d
        
        def _encode_column(col_type):
            res = np.zeros((37))
            res[col_type] = 1
            if col_type > 14:
                res[-1] = 1
            return res
        
        if mask is not None:
            df=dataframe.iloc[mask].copy()
        else:
            df=dataframe
        
        self.index=_make_index(df["Formula"].values, unique_formulas)
        self.ris = df["RI"].values/1000
        cols = df["ColType"].values
        self.en_cols=np.vstack(list(map(_encode_column,cols)))
        self.en_2d=en_2d

    def __getitem__(self, index):
        col_encoded = torch.FloatTensor(self.en_cols[index])
        en_2d= torch.FloatTensor(self.en_2d[self.index[index]])
        return (en_2d, col_encoded, self.ris[index])

    def __len__(self):
        return len(self.ris)
    
def get_train_test_dataloaders(df_name:str,en_2d:np.array,formulas:np.array,batch_size:int)->tuple:
    """Prepares train and test dataloaders by splitting input data
    into respective CNN2D datasets.

    Parameters
    ----------
    df_name : str
        name of dataframe with smiles, column type and retention index
    en_2d : np.array
        Array with pre-encoded 2D images of molecules: two coordinate axes
        and channels as a third  OHE-encoded one
    formulas : np.array or list
        Array of unique formulas in the dataset that was generated
        when images of molecules were encoded
    batch_size : int
        Batch size for the two dataloaders

    Returns
    -------
    tuple (DataLoader, DataLoader)
        tuple containing train and test DataLoaders respectively
    """
    df = pd.read_csv(df_name)
    df.columns = ["Formula", "RI", "ColType"]
    _,tst_unique=train_test_split(list(formulas),test_size=0.2,random_state=42)
    trn_mask,tst_mask=[],[]
    tst_unique=set(tst_unique)
    for i,val in enumerate(df["Formula"].values):
        if val in tst_unique:
            tst_mask.append(i)
        else:
            trn_mask.append(i)
    trn_ds=CNN2D_Dataset(df,en_2d,formulas,trn_mask)
    tst_ds=CNN2D_Dataset(df,en_2d,formulas,tst_mask)
    return (DataLoader(trn_ds, batch_size,pin_memory=True,num_workers=4), 
            DataLoader(tst_ds, batch_size,pin_memory=True,num_workers=4))

def get_val_dataloader(df_name:str,en_2d:np.array,formulas:np.array,batch_size:int)->DataLoader:
    """Prepares validation dataloader.

    Parameters
    ----------
    df_name : str
        name of dataframe with smiles, column type and retention index
    en_2d : np.array
        Array with pre-encoded 2D images of molecules: two coordinate axes
        and channels as a third  OHE-encoded one
    formulas : np.array or list
        Array of unique formulas in the dataset that was generated
        when images of molecules were encoded
    batch_size : int
        Batch size for the dataloader

    Returns
    -------
    DataLoader
        validation DataLoader
    """
    df = pd.read_csv(df_name)
    df.columns = ["Formula", "RI", "ColType"]
    ds = CNN2D_Dataset(df,en_2d,formulas)
    return DataLoader(ds, batch_size,pin_memory=True,num_workers=4)